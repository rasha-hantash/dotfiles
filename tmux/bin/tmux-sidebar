#!/usr/bin/env zsh
# tmux-sidebar â€” interactive session navigator for CCS
# Focus with âŒ˜P (Ghostty) or Ctrl+a s (tmux)

SESSION="ccs"
selected=0
window_count=0

# â”€â”€ Catppuccin Mocha â”€â”€
C_PEACH=$'\033[38;2;250;179;135m'
C_BLUE=$'\033[38;2;137;180;250m'
C_OVERLAY=$'\033[38;2;108;112;134m'
C_SURFACE=$'\033[38;2;69;71;90m'
C_BOLD=$'\033[1m'
C_R=$'\033[0m'
ESC=$'\033'

# â”€â”€ Legend (static â€” declared once) â”€â”€
leg_keys=("âŒ˜ + j" "âŒ˜ + m" "âŒ˜ + p" "âŒ˜ + ;")
leg_labels=("claude" "terminal" "sessions" "exit")
leg_count=${#leg_keys[@]}

typeset -a win_indices win_names win_branches win_worktrees

# â”€â”€ Cached terminal dimensions (rebuilt on SIGWINCH) â”€â”€
cols=$(tput cols)
lines=$(tput lines)
sep="${C_SURFACE}$(printf '%.0sâ”€' {1..$cols})${C_R}"

rebuild_geometry() {
    cols=$(tput cols)
    lines=$(tput lines)
    sep="${C_SURFACE}$(printf '%.0sâ”€' {1..$cols})${C_R}"
}

trap 'rebuild_geometry' WINCH

tput civis
tput rmam
trap 'tput cnorm; tput smam' EXIT

refresh_windows() {
    win_indices=()
    win_names=()
    win_branches=()
    win_worktrees=()
    window_count=0
    local active_pos=0
    while IFS='|' read -r idx active name pane_path; do
        win_indices+=("$idx")
        win_names+=("$name")
        [[ $active == "1" ]] && active_pos=$window_count
        # Get branch name and worktree status from the pane's working dir
        local branch="" is_wt=""
        if [[ -n $pane_path ]] && branch=$(git -C "$pane_path" rev-parse --abbrev-ref HEAD 2>/dev/null); then
            local git_dir common_dir
            git_dir=$(git -C "$pane_path" rev-parse --git-dir 2>/dev/null)
            common_dir=$(git -C "$pane_path" rev-parse --git-common-dir 2>/dev/null)
            [[ $git_dir != "$common_dir" ]] && is_wt="1"
        fi
        win_branches+=("$branch")
        win_worktrees+=("$is_wt")
        ((window_count++))
    done < <(tmux list-windows -t "$SESSION" -F '#{window_index}|#{window_active}|#{window_name}|#{pane_current_path}')
    # Always sync to the tmux-active window. Each window runs its own
    # sidebar process, so after a window switch the new sidebar must
    # pick up whichever window is now active.
    selected=$active_pos
    # Clamp in case of race
    (( selected >= window_count && window_count > 0 )) && selected=$(( window_count - 1 ))
}

render() {
    local right_col=$(( cols - 18 ))
    (( right_col < 0 )) && right_col=0

    local max_rows=$(( window_count > leg_count ? window_count : leg_count ))
    (( max_rows < 1 )) && max_rows=1

    # Build entire frame into buffer, print in one write (no flicker)
    local buf=""

    # â”€â”€ Header â”€â”€
    local plural=""
    [[ $window_count -ne 1 ]] && plural="s"
    buf+="${ESC}[1;1H"
    buf+=" ${C_OVERLAY}${window_count} session${plural}${C_R} ${C_OVERLAY}Â·${C_R} ${C_BLUE}â†‘â†“${C_R}${C_OVERLAY} switch${C_R}${ESC}[K"

    # â”€â”€ Separator â”€â”€
    buf+="${ESC}[2;1H"
    buf+="${sep}${ESC}[K"

    # â”€â”€ Two-column body: sessions (left) + legend (right) â”€â”€
    local row=0
    while (( row < max_rows )); do
        local line_num=$(( row + 2 ))
        local ansi_row=$(( line_num + 1 ))

        # Position at left edge, overwrite session content in-place
        buf+="${ESC}[${ansi_row};1H"

        if (( row < window_count )); then
            local name="${win_names[$((row+1))]}"
            local branch="${win_branches[$((row+1))]}"
            local is_wt="${win_worktrees[$((row+1))]}"
            local branch_suffix=""
            if [[ -n $branch ]]; then
                branch_suffix=" ${C_SURFACE}${branch}${C_R}"
                [[ -n $is_wt ]] && branch_suffix+=" ðŸŒ³"
            fi
            if [[ $row -eq $selected ]]; then
                buf+=" ${C_PEACH}â—${C_R} ${C_PEACH}${C_BOLD}${name}${C_R}${branch_suffix}"
            else
                buf+=" ${C_OVERLAY}Â·${C_R} ${C_OVERLAY}${name}${C_R}${branch_suffix}"
            fi
        fi
        # Erase from cursor to end of line (clears stale trailing chars)
        buf+="${ESC}[K"

        # Right column: legend (overwrites area we just cleared)
        if (( row < leg_count )); then
            buf+="${ESC}[${ansi_row};$((right_col + 1))H"
            buf+="${C_BLUE}${leg_keys[$((row+1))]}${C_R}  ${C_OVERLAY}${leg_labels[$((row+1))]}${C_R}${ESC}[K"
        fi

        ((row++))
    done

    # â”€â”€ Clear to bottom â”€â”€
    buf+="${ESC}[$(( max_rows + 3 ));1H${ESC}[J"

    printf '%s' "$buf"
}

# â”€â”€ Main loop â”€â”€
tick=0
REFRESH_EVERY=2  # refresh window list every 2 ticks (~0.2s)

while true; do
    if (( tick % REFRESH_EVERY == 0 )); then
        refresh_windows
    fi
    render

    if read -rsk1 -t 0.1 key 2>/dev/null; then
        # Sync selected to the active window before processing.
        # Another sidebar instance may have just switched to this
        # window, leaving our selected stale.
        refresh_windows
        local moved=0

        # Process this key
        if [[ $key == $'\033' ]]; then
            read -rsk2 -t 0.1 rest 2>/dev/null
            case "$rest" in
                '[A') (( selected > 0 )) && (( --selected, 1 )) && moved=1 ;;
                '[B') (( selected < window_count - 1 )) && (( ++selected )) && moved=1 ;;
            esac
        elif [[ $key == 'q' ]]; then
            break
        elif [[ $key == $'\n' || $key == $'\r' ]]; then
            tmux select-window -t "$SESSION:${win_indices[$((selected+1))]}" \; select-pane -t :.1
            refresh_windows
            tick=0
            continue
        fi

        # Drain queued keys â€” batch rapid arrow presses into one move
        while read -rsk1 -t 0 key 2>/dev/null; do
            if [[ $key == $'\033' ]]; then
                read -rsk2 -t 0.02 rest 2>/dev/null
                case "$rest" in
                    '[A') (( selected > 0 )) && (( --selected, 1 )) && moved=1 ;;
                    '[B') (( selected < window_count - 1 )) && (( ++selected )) && moved=1 ;;
                esac
            fi
        done

        # Single tmux call after all queued keys are processed
        if (( moved )); then
            tmux select-window -t "$SESSION:${win_indices[$((selected+1))]}" \; select-pane -t :.3
        fi

        # Start tick at 1 so the next iteration won't immediately
        # call refresh_windows (tick % REFRESH_EVERY != 0), giving
        # the select-window command time to take effect.
        tick=1
    fi
    ((tick++))
done
