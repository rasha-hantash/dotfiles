#!/usr/bin/env zsh
# tmux-sidebar — interactive session navigator for CCS
# Focus with ⌘P (Ghostty) or Ctrl+a s (tmux)

SESSION="ccs"
selected=0
window_count=0

# ── Catppuccin Mocha ──
C_PEACH=$'\033[38;2;250;179;135m'
C_BLUE=$'\033[38;2;137;180;250m'
C_OVERLAY=$'\033[38;2;108;112;134m'
C_SURFACE=$'\033[38;2;69;71;90m'
C_BOLD=$'\033[1m'
C_R=$'\033[0m'
ESC=$'\033'

# ── Legend (static — declared once) ──
leg_keys=("⌘ + j" "⌘ + m" "⌘ + p" "⌘ + ;")
leg_labels=("claude" "terminal" "sessions" "exit")
leg_count=${#leg_keys[@]}

typeset -a win_indices win_names

# ── Cached terminal dimensions (rebuilt on SIGWINCH) ──
cols=$(tput cols)
lines=$(tput lines)
sep="${C_SURFACE}$(printf '%.0s─' {1..$cols})${C_R}"

rebuild_geometry() {
    cols=$(tput cols)
    lines=$(tput lines)
    sep="${C_SURFACE}$(printf '%.0s─' {1..$cols})${C_R}"
}

trap 'rebuild_geometry' WINCH

tput civis
tput rmam
trap 'tput cnorm; tput smam' EXIT

refresh_windows() {
    win_indices=()
    win_names=()
    window_count=0
    local active_pos=0
    while IFS='|' read -r idx active name; do
        win_indices+=("$idx")
        win_names+=("$name")
        [[ $active == "1" ]] && active_pos=$window_count
        ((window_count++))
    done < <(tmux list-windows -t "$SESSION" -F '#{window_index}|#{window_active}|#{window_name}')
    selected=$active_pos
}

render() {
    local right_col=$(( cols - 18 ))
    (( right_col < 0 )) && right_col=0

    local max_rows=$(( window_count > leg_count ? window_count : leg_count ))
    (( max_rows < 1 )) && max_rows=1

    # Build entire frame into buffer, print in one write (no flicker)
    local buf=""

    # ── Header ──
    local plural=""
    [[ $window_count -ne 1 ]] && plural="s"
    buf+="${ESC}[1;1H"
    buf+=" ${C_OVERLAY}${window_count} session${plural}${C_R} ${C_OVERLAY}·${C_R} ${C_BLUE}↑↓${C_R}${C_OVERLAY} switch${C_R}${ESC}[K"

    # ── Separator ──
    buf+="${ESC}[2;1H"
    buf+="${sep}${ESC}[K"

    # ── Two-column body: sessions (left) + legend (right) ──
    local row=0
    while (( row < max_rows )); do
        local line_num=$(( row + 2 ))
        local ansi_row=$(( line_num + 1 ))

        # Position at left edge, overwrite session content in-place
        buf+="${ESC}[${ansi_row};1H"

        if (( row < window_count )); then
            local name="${win_names[$((row+1))]}"
            if [[ $row -eq $selected ]]; then
                buf+=" ${C_PEACH}●${C_R} ${C_PEACH}${C_BOLD}${name}${C_R}"
            else
                buf+=" ${C_OVERLAY}·${C_R} ${C_OVERLAY}${name}${C_R}"
            fi
        fi
        # Erase from cursor to end of line (clears stale trailing chars)
        buf+="${ESC}[K"

        # Right column: legend (overwrites area we just cleared)
        if (( row < leg_count )); then
            buf+="${ESC}[${ansi_row};$((right_col + 1))H"
            buf+="${C_BLUE}${leg_keys[$((row+1))]}${C_R}  ${C_OVERLAY}${leg_labels[$((row+1))]}${C_R}${ESC}[K"
        fi

        ((row++))
    done

    # ── Clear to bottom ──
    buf+="${ESC}[$(( max_rows + 3 ));1H${ESC}[J"

    printf '%s' "$buf"
}

# ── Main loop ──
tick=0
REFRESH_EVERY=10  # refresh window list every 10 ticks (~1s)

while true; do
    if (( tick % REFRESH_EVERY == 0 )); then
        refresh_windows
    fi
    render

    if read -rsk1 -t 0.1 key 2>/dev/null; then
        if [[ $key == $'\033' ]]; then
            read -rsk2 -t 0 rest 2>/dev/null
            case "$rest" in
                '[A') # Up — keep focus in sidebar for multi-step navigation
                    if (( selected > 0 )); then
                        (( selected-- ))
                        tmux select-window -t "$SESSION:${win_indices[$((selected+1))]}" \; select-pane -t :.3
                    fi
                    ;;
                '[B') # Down — keep focus in sidebar for multi-step navigation
                    if (( selected < window_count - 1 )); then
                        (( selected++ ))
                        tmux select-window -t "$SESSION:${win_indices[$((selected+1))]}" \; select-pane -t :.3
                    fi
                    ;;
            esac
        elif [[ $key == 'q' ]]; then
            break
        elif [[ $key == $'\n' || $key == $'\r' ]]; then
            # Enter — commit selection and jump to Claude pane
            tmux select-window -t "$SESSION:${win_indices[$((selected+1))]}" \; select-pane -t :.1
        fi
        # Immediate refresh after any key press
        refresh_windows
        tick=0
    fi
    ((tick++))
done
