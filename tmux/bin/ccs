#!/usr/bin/env bash
# ccs â€” Claude Code session manager
# Manages multiple Claude Code sessions inside tmux

SESSION="ccs"

# â”€â”€ Catppuccin Mocha â”€â”€
C_PEACH=$'\033[38;2;250;179;135m'
C_LAVENDER=$'\033[38;2;180;190;254m'
C_BLUE=$'\033[38;2;137;180;250m'
C_SUBTEXT=$'\033[38;2;166;173;200m'
C_OVERLAY=$'\033[38;2;108;112;134m'
C_SURFACE=$'\033[38;2;69;71;90m'
C_BOLD=$'\033[1m'
C_R=$'\033[0m'

setup_layout() {
    local win="$SESSION:$1"
    tmux set-option -w -t "$win" remain-on-exit on \; \
        split-window -t "$win" -v -p 25 \; \
        split-window -t "$win.2" -h -p 30 "~/.local/bin/tmux-sidebar" \; \
        select-pane -t "$win.1" \; \
        send-keys -t "$win.1" "claude" Enter
}

usage() {
    printf "%s%sccs%s â€” Claude Code session manager\n" "$C_LAVENDER" "$C_BOLD" "$C_R"
    printf "\n"
    printf "%sUsage:%s\n" "$C_BLUE" "$C_R"
    printf "  %scss start%s [name] [dir]    Start or add a session tab\n" "$C_PEACH" "$C_R"
    printf "  %scss list%s                  List active sessions\n" "$C_PEACH" "$C_R"
    printf "  %scss kill%s  [name]          Kill a session tab (interactive picker)\n" "$C_PEACH" "$C_R"
    printf "  %scss all-kill%s              Kill all sessions\n" "$C_PEACH" "$C_R"
    printf "  %scss help%s                  Show this help\n" "$C_PEACH" "$C_R"
    printf "\n"
    printf "%sExamples:%s\n" "$C_BLUE" "$C_R"
    printf "  %s\$%s ccs start pancake ~/workspace/personal/pancake\n" "$C_OVERLAY" "$C_R"
    printf "  %s\$%s ccs start rag ~/workspace/personal/technical-rag\n" "$C_OVERLAY" "$C_R"
    printf "  %s\$%s ccs list\n" "$C_OVERLAY" "$C_R"
    printf "  %s\$%s ccs kill rag\n" "$C_OVERLAY" "$C_R"
}

cmd_start() {
    local name=${1:-"session-1"}
    local dir=${2:-$(pwd)}

    if tmux has-session -t "$SESSION" 2>/dev/null; then
        # Session exists â€” add a new window
        tmux new-window -t "$SESSION" -n "$name" -c "$dir"
        setup_layout "$name"

        # If we're outside tmux, attach so the user sees it
        if [ -z "$TMUX" ]; then
            tmux attach -t "$SESSION"
        fi
    else
        # No session â€” create from scratch.
        # new-session must run outside tmux to get real terminal dimensions.
        if [ -n "$TMUX" ]; then
            printf "No ccs session exists. Run from outside tmux first:\n"
            printf "  %scss start%s %s %s\n" "$C_PEACH" "$C_R" "$name" "$dir"
            return 1
        fi

        tmux new-session -s "$SESSION" -n "$name" -c "$dir" \; \
            set-option -w remain-on-exit on \; \
            set-hook pane-died 'respawn-pane' \; \
            split-window -v -p 25 \; \
            split-window -t .2 -h -p 30 "~/.local/bin/tmux-sidebar" \; \
            select-pane -t .1 \; \
            send-keys -t .1 "claude" Enter
    fi
}

get_branch_info() {
    local pane_path="$1"
    local branch="" git_dir="" common_dir=""
    if [[ -n $pane_path ]] && branch=$(git -C "$pane_path" rev-parse --abbrev-ref HEAD 2>/dev/null); then
        git_dir=$(git -C "$pane_path" rev-parse --git-dir 2>/dev/null)
        common_dir=$(git -C "$pane_path" rev-parse --git-common-dir 2>/dev/null)
        printf "%s" "$branch"
        [[ $git_dir != "$common_dir" ]] && printf " ðŸŒ³"
    fi
}

cmd_list() {
    if ! tmux has-session -t "$SESSION" 2>/dev/null; then
        printf "%sNo active ccs session.%s\n" "$C_OVERLAY" "$C_R"
        return 1
    fi

    tmux list-windows -t "$SESSION" -F '#{window_index}|#{window_name}|#{window_active}|#{pane_current_path}' | \
    while IFS='|' read -r _idx name active dir; do
        local branch_info
        branch_info=$(get_branch_info "$dir")
        local branch_display=""
        [[ -n $branch_info ]] && branch_display="  ${C_SURFACE}${branch_info}${C_R}"
        dir="${dir/#$HOME/\~}"
        if [ "$active" = "1" ]; then
            printf "  %sâ—%s %s%s%s%s%s  %s%s%s\n" "$C_PEACH" "$C_R" "$C_PEACH" "$C_BOLD" "$name" "$C_R" "$branch_display" "$C_SUBTEXT" "$dir" "$C_R"
        else
            printf "  %sÂ·%s %s%s%s%s  %s%s%s\n" "$C_OVERLAY" "$C_R" "$C_OVERLAY" "$name" "$C_R" "$branch_display" "$C_SURFACE" "$dir" "$C_R"
        fi
    done
}

cmd_kill() {
    if ! tmux has-session -t "$SESSION" 2>/dev/null; then
        printf "%sNo active ccs session.%s\n" "$C_OVERLAY" "$C_R"
        return 1
    fi

    # No argument â€” show picker with all windows
    if [[ -z ${1:-} ]]; then
        cmd_kill_picker
        return
    fi

    local name="$1"

    # Collect windows matching this name
    local -a match_indices=() match_names=() match_paths=()
    while IFS='|' read -r idx wname ppath; do
        if [[ $wname == "$name" ]]; then
            match_indices+=("$idx")
            match_names+=("$wname")
            match_paths+=("$ppath")
        fi
    done < <(tmux list-windows -t "$SESSION" -F '#{window_index}|#{window_name}|#{pane_current_path}')

    if [[ ${#match_indices[@]} -eq 0 ]]; then
        printf "No window named '%s%s%s'.\n" "$C_PEACH" "$name" "$C_R"
        return 1
    elif [[ ${#match_indices[@]} -eq 1 ]]; then
        tmux kill-window -t "$SESSION:${match_indices[0]}"
        printf "Killed: %s%s%s\n" "$C_PEACH" "$name" "$C_R"
    else
        cmd_kill_picker "$name"
    fi
}

cmd_kill_picker() {
    local filter="${1:-}"
    local -a pick_indices=() pick_names=() pick_paths=()

    while IFS='|' read -r idx wname ppath; do
        if [[ -z $filter || $wname == "$filter" ]]; then
            pick_indices+=("$idx")
            pick_names+=("$wname")
            pick_paths+=("$ppath")
        fi
    done < <(tmux list-windows -t "$SESSION" -F '#{window_index}|#{window_name}|#{pane_current_path}')

    local count=${#pick_indices[@]}
    if [[ $count -eq 0 ]]; then
        printf "%sNo sessions to kill.%s\n" "$C_OVERLAY" "$C_R"
        return 1
    fi

    if [[ -n $filter ]]; then
        printf "\n  %sMultiple sessions for %s%s%s:%s\n" "$C_OVERLAY" "$C_PEACH" "$filter" "$C_OVERLAY" "$C_R"
    else
        printf "\n  %sSelect session to kill:%s\n" "$C_OVERLAY" "$C_R"
    fi

    local sel=0

    # Hide cursor
    tput civis
    trap 'tput cnorm' RETURN

    while true; do
        # Render list
        for (( i=0; i<count; i++ )); do
            local branch_info
            branch_info=$(get_branch_info "${pick_paths[$i]}")
            local branch_display=""
            [[ -n $branch_info ]] && branch_display="  ${C_SURFACE}${branch_info}${C_R}"

            if [[ $i -eq $sel ]]; then
                printf "  %sâ—%s %s%s%s%s%s\n" "$C_PEACH" "$C_R" "$C_PEACH" "$C_BOLD" "${pick_names[$i]}" "$C_R" "$branch_display"
            else
                printf "  %sÂ·%s %s%s%s%s\n" "$C_OVERLAY" "$C_R" "$C_OVERLAY" "${pick_names[$i]}" "$C_R" "$branch_display"
            fi
        done
        printf "\n  %sâ†‘â†“%s%s select Â· enter kill Â· q cancel%s\n" "$C_BLUE" "$C_R" "$C_OVERLAY" "$C_R"

        # Read key
        local key=""
        IFS= read -rsn1 key
        if [[ $key == $'\033' ]]; then
            local rest=""
            IFS= read -rsn2 -t 0.1 rest
            case "$rest" in
                '[A') (( sel > 0 )) && (( sel-- )) ;;
                '[B') (( sel < count - 1 )) && (( sel++ )) ;;
            esac
        elif [[ $key == '' || $key == $'\n' ]]; then
            tmux kill-window -t "$SESSION:${pick_indices[$sel]}"
            printf "\r\033[K  Killed: %s%s%s\n" "$C_PEACH" "${pick_names[$sel]}" "$C_R"
            return 0
        elif [[ $key == 'q' ]]; then
            printf "\r\033[K  %sCancelled.%s\n" "$C_OVERLAY" "$C_R"
            return 0
        fi

        # Move cursor back up to redraw
        local lines_to_clear=$(( count + 2 ))
        printf "\033[${lines_to_clear}A"
        for (( i=0; i<lines_to_clear; i++ )); do
            printf "\033[K\n"
        done
        printf "\033[${lines_to_clear}A"
    done
}

cmd_kill_all() {
    if ! tmux has-session -t "$SESSION" 2>/dev/null; then
        printf "%sNo active ccs session.%s\n" "$C_OVERLAY" "$C_R"
        return 1
    fi

    tmux kill-session -t "$SESSION"
    printf "Killed all sessions.\n"
}

case "${1:-help}" in
    start|new) shift; cmd_start "$@" ;;
    list|ls) shift; cmd_list "$@" ;;
    kill)   shift; cmd_kill "$@" ;;
    all-kill) cmd_kill_all ;;
    help|-h|--help) usage ;;
    *)
        printf "Unknown command: %s\n" "$1"
        printf "Run '%scss help%s' for usage.\n" "$C_PEACH" "$C_R"
        exit 1
        ;;
esac
